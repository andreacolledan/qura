--- Quantum Fourier Transform with width and depth analysis

--- Parameters:
--- n     : size of the input to the QFT
--- d     : initial depth of the input qubits
--- iter  : current iteration of the QFT


--- HELPER FUNCTIONS ---

-- invert the list of intermediate qubits at iteration iter
let qrev = lift forall iter. forall d.
  \reg :: List[i<iter] Qubit{d+iter+i}.
    let revStep = lift forall step.
      \(rev, q) :: (List[i<step] Qubit{d+2*iter-(i+1)}, Qubit{d+2*iter-(step+1)}).
        rev:q in
    fold(revStep, [], reg)
in

-- apply the controlled rotation gate to the target qubit trg at iteration iter
let rotate = forall d. forall iter. lift forall step.
  \((ctrls, trg), ctrl)::((List[i<step] Qubit{d+iter+i+1}, Qubit{d+iter+step}), Qubit{d+iter+step}).
    let (ctrl, trg) = (force cr @(iter+1-step) @(d+iter+step) @(d+iter+step)) ctrl trg in
    (ctrls:ctrl, trg) -- :: (List[i<step+1] Qubit{d+iter+i+1}, Qubit{d+iter+step+1})
in


--- QUANTUM FOURIER TRANSFORM ---

-- apply the Quantum Fourier Transform to n qubits at depth d
let qft = lift forall n. forall d.
  \reg :: List[i<n] Qubit{d}.
    let qftIter = lift forall iter. -- define the iteration of the QFT
      \(ctrls, trg)::(List[i<iter] Qubit{d+iter+i}, Qubit{d}).
        let revctrls = (force qrev @iter @d) ctrls in -- List[i<iter] Qubit{d+2*iter-(i+1)}
        let (ctrls, trg) = fold(rotate @d @iter, ([], trg), revctrls) in
        -- note (ctrls, trg) :: (List[i<iter] Qubit{d+iter+i+1}, Qubit{d+2*iter})
        let trg = (force hadamard @(d+2*iter)) trg in
        ctrls:trg -- List[i<iter+1] Qubit{d+iter+1+i}
    in fold(qftIter, [], reg) -- List[i<n] Qubit{d+n+i}
in

qft -- uncomment for generic, parametric bound
--(force qft @4 @0) [(force qinit0), (force qinit0), (force qinit0), (force qinit0)] -- uncomment for instance bounds